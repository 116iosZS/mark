
# 多线程与网络

**concurrent**

- [多线程基础](#多线程基础)
	- [进程的基本概念](#进程的基本概念)
	- [多线程的基本概念](#多线程的基本概念)
	- [线程的创建与启动](#线程的创建与启动)
	- [NSThread的常用方法](#NSThread的常用方法)
	- [GCD创建队列](#GCD创建队列)
	- [子线程的内存管理](#子线程的内存管理)
	- [NSRunloop的基本概念](#NSRunloop的基本概念)
	- [定时器在多线程的使用](#定时器在多线程的使用)
- [GCD](#GCD)

***

**network**

- [网络请求基础](#网络请求基础)
	- [HTTP请求](#HTTP请求)
	- [HTTP响应](#HTTP响应)
	- [访问网络的基本流程](#访问网络的基本流程)
	- [NSURLRequest的使用](#NSURLRequest的使用)
	- [同步请求用法](#同步请求用法)
	- [异步请求用法](#异步请求用法)
	- [xml和json的基本概念](#xml和json的基本概念)
	- [解析的开源框架](#解析的开源框架)
- [ASIHTTPRequest](#ASIHTTPRequest)

<h1 id="多线程基础"> 多线程基础 </h1>

<h2 id="进程的基本概念"> 进程的基本概念 </h2>

- 每一个进程都是一个应用程序,都有独立的内存空间,一般来说一个应用程序存在
- 一个进程,但也多个进程的情况
- 视图的操作一定 · 要主线程来完
- 同一个进程中的线程共享内存中内存和资源成

<h2 id="多线程的基本概念"> 多线程的基本概念 </h2>

- 每一个程序都有一个主线程,程序启动时创建(调用main来启动)
- 主线程的生命周期是和应用程序绑定的,程序退出(结束)时,主线程也就停止了
- 多线程技术表示,一个应用程序有多个线程,使用多线程能提供CPU的使用率,防 止主线程堵塞
- 任何有可能堵塞主线程的任务不要在主线程执行(访问网络)

<h2 id="线程的创建与启动"> 线程的创建与启动 </h2>

	// 1. 第一种开启新的线程调⽤mutableThread
	NSThread *t = [[NSThread alloc] initWithTarget:self
	object:nil];
	[t start]; // 需要⼿手动开启
	selector:@selector(mutableThread)
	// 2. 第二种开启新的线程调⽤用 mutableThread
	[NSThread detachNewThreadSelector:@selector(mutableThread)
	                           toTarget:self withObject:nil];
	// 3. 第三种开启新的线程调⽤用 mutableThread
	[self performSelectorInBackground:@selector(mutableThread)
	                         withObject:nil];
	// 4.block语法启动y一个线程
	NSOperationQueue *threadQueue = [[NSOperationQueue alloc] init];
	    [threadQueue addOperationWithBlock:^(void) {
	}];
	NSThread *t = [NSThread currentThread];
	if (![t isMainThread]) {
	    NSLog(@"是多线程");
	}
	// 5.NSOperation开启y一个线程
	NSOperationQueue *threadQueue = [[NSOperationQueue alloc] init];
	NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self
	                                                                 selector:@selector(mutableThread)
	                                                                   object:nil];
	[threadQueue addOperation:op];
	// 在主线程上调⽤用 reloadData ⽅方法
	[self performSelectorOnMainThread:@selector(reloadData)
	                      withObject:nil waitUntilDone:NO];

<h2 id="NSThread的常用方法"> NSThread的常用方法 </h2>

	// 判断当前线程是否是多线程
	+ (BOOL)isMultiThreaded;
	// 获取当前线程对象
	+ (NSThread *)currentThread;
	// 使当前线程睡眠指定的时间,单位为秒
	+ (void)sleepForTimeInterval:(NSTimeInterval)ti;
	// 退出当前线程
	+ (void)exit;
	// 判断当前线程是否为主线程
	+ (BOOL)isMainThread
	// 启动该线程
	- (void)start

<h2 id="GCD创建队列"> GCD创建队列 </h2>

	// 创建y一个队列
	dispatch_queue_t queue = dispatch_queue_create("test", NULL); 
	// 创建异步线程
	dispatch_async(queue, ^{
	    // 多线程
	    // 回到主线程执⾏
	    dispatch_async(dispatch_get_main_queue(), ^{
	    // 主线程
	    });
	});

<h2 id="子线程的内存管理"> 子线程的内存管理 </h2>

	// 创建⼦子线程
	[self performSelectorInBackground:@selector(mutableThread)
	                         withObject:nil];
	- (void)mutableThread {
	    // 创建⾃自动释放池
	    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
	    for (int i=0; i<10; i++) {
	        NSLog(@"%d",i);
	        [NSThread sleepForTimeInterval:1];
	  }
	  [self performSelectorOnMainThread:@selector(reloadData)
	                          withObject:nil
	                      waitUntilDone:NO];
	  [pool release];
	}

<h2 id="NSRunloop的基本概念"> NSRunloop的基本概念 </h2>

- Run loops 是线程相关的的基础框架的一部分
- 一个 run loop 就是一个事件处理 的循环,用来不停的调度工作以及处理输入事件
- 线程的生命周期存在五个状态:新建、就绪、运行、阻塞、死亡 
- NSRunLoop可以保持一个线程一直为活动状态,不会马上销毁掉

<h2 id="定时器在多线程的使用"> 定时器在多线程的使用 </h2>

在多线程中使用定时器必须开启Runloop,因为只有开启Runloop保持线程为活动 状态,才能保持定时器能不断执行

	- (void)runThread {
	    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
	    [NSTimer scheduledTimerWithTimeInterval:1
	                                     target:self
	                                   selector:@selector(timeAction)
	                                   userInfo:nil
	                                    repeats:YES];
	     // 开启Runloop来使线程保持存活状态
	     [[NSRunLoop currentRunLoop] run];
	     [pool release];
	}

<h1 id="GCD"> GCD </h1>

- The main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。

  main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的,
  所以这是一个串行队列。
- Global queues: 全局队列是并发队列，并由整个进程共享。

  进程中存在三个全局队列：高、中（默认）、低三个优先级队列。
  可以调用dispatch_get_global_queue函数传入优先级来访问队列。
- 用户队列: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列) 是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。

		dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
		        [self goDoSomethingLongAndInvolved];
				        dispatch_async(dispatch_get_main_queue(), ^{
							[textField setStringValue:@"Done doing something long and involved"];
						});
		});

		dispatch_queue_t bgQueue = myQueue;
		    dispatch_async(dispatch_get_main_queue(), ^{
				NSString *stringValue = [[[textField stringValue] copy] autorelease];
					dispatch_async(bgQueue, ^{
						// use stringValue in the background now
					});
		});

要用于同步机制，queue必须是一个用户队列，而非全局队列，所以使用usingdispatch_queue_create初始化一个。
然后可以用dispatch_async 或者 dispatch_sync将共享数据的访问代码封装起来：

	- (id)something {
		
	    __block id localSomething;
		dispatch_sync(queue, ^{
			localSomething = [something retain];
		});
		return [localSomething autorelease];
	}							 

	- (void)setSomething:(id)newSomething {
		
		dispatch_async(queue, ^{
			if(newSomething != something) {
				[something release];
				something = [newSomething retain];
				[self updateSomethingCaches];
			}
		});
	}

<h2 id="GCD执行类别"> GCD执行类别 </h2>

***

<h1 id="网络请求基础"> 网络请求基础 </h1>

<h2 id="HTTP请求"> HTTP请求 </h2>

	Http请求主要由两部分组成:http请求头、http请求体 ·POST请求才有请求体 ·请求的参数有两种形式:1.放在URL后面,2.放在请求体中
	URL: http://weibo.com/mechenwei?page=1&pagesize=20
	HTTP请求头:
	Accept: text/html,application/xhtml+xml,application/ xml;q=0.9,*/*;q=0.8
	Accept-Charset: GBK,utf-8;
	Accept-Encoding: gzip,deflate,sdch
	Accept-Language: zh-CN,zh;
	Connection: keep-alive

	HTTP请求体: userName=wxhl&password=wxhl2805

<h2 id="HTTP响应"> HTTP响应 </h2>

HTTP响应主要由两部分组成:响应头、响应内容 ·HTTP响应有个状态码,标示响应的结果,例如200表示成功,404未找到页面

	HTTP响应头:
	Cache-Control:no-cache, must-revalidate Connection:close
	Content-Encoding:gzip Content-Type:text/html; charset=utf-8 Date:Thu, 10 Jan 2013 02:41:29 GMT DPOOL_HEADER:alice82

	HTTP响应体: {username:”wxhl”,success:true};

<h2 id="访问网络的基本流程"> 访问网络的基本流程 </h2>

- 构造NSURL实例(地址)
- 生成NSURLRequest请求
- 通过NSURLConnection发送请求
- 通过返回NSURLRespond实例和NSError实例分析结果
- 接受返回数据

<h2 id="NSURLRequest的使用"> NSURLRequest的使用 </h2>

	NSURLRequest 包装了网络请求的信息。
	NSURL *url = [NSURL URLWithString:@"http://www.baidu.com:8080/search?id=1"];
	cachePolicy 缓存策略 
	timeoutInterval 超时时间 
	NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60];

	NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];
	[request setURL:url];
	// 设置请求⽅方式
	[request setHTTPMethod:@"POST"];
	// 设置超时时间
	[request setTimeoutInterval:60];
	// 设置请求参数
	[request setHTTPBody:_data];
	// 设置请求头
	[request setValue:@"tttt" forHTTPHeaderField:@"cookes"];

<h2 id="同步请求用法"> 同步请求用法 </h2>

	// 构造url
	NSURL *url = [NSURL URLWithString:@"http://www.iphonetrain.com"];
	// 创建y一个请求对象
	NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLResponse *response;
	// 发送同步请求,请求成功后返回数据
	NSData *resultData = [NSURLConnection sendSynchronousRequest:request
	                                    returningResponse:&response
	                                                error:nil];
	NSString *dataString = [[NSString alloc] initWithData:resultData
	                                     encoding:NSUTF8StringEncoding];
	self.resultText.text = dataString;

<h2 id="异步请求用法"> 异步请求用法 </h2>

- 第一种方式

		NSURL *url = [NSURL URLWithString:request_url];
		NSURLRequest *request = [NSURLRequest requestWithURL:url];
		// 发送异步请求
		[NSURLConnection connectionWithRequest:request delegate:self];
		- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
		    [_data appendData:data];
		} 

		// 接受加载的数据
		- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
		    NSString *dataString = [[NSString alloc] initWithData:_data encoding:NSUTF8StringEncoding];
		    self.resultText.text = dataString; 
		} 
		// 数据加载完以后调⽤用

- 第二种方式

		// 开一个子线程
		- (IBAction)asychroRequest:(id)sender {
		      [self performSelectorInBackground:@selector(loadData) withObject:nil];
		  } 
		// 启动y一个新的线程加载数据
		- (void)loadData {
		    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; NSURL *url = [NSURL URLWithString:request_url];
		    NSURLRequest *request = [NSURLRequest requestWithURL:url]; NSURLResponse *response = nil;
		    // 发送同步请求
		   NSData *data = [NSURLConnection sendSynchronousRequest:request
		                                       returningResponse:&response
		                                                   error:nil];
		   NSString *stringData = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
		   [self performSelectorOnMainThread:@selector(afterLoadData:) withObject:stringData waitUntilDone:NO];
		   [pool release];
		}

<h2 id="xml和json的基本概念"> xml和json的基本概念 </h2>

- xml:可扩展标记语言,是一种数据交换格式,解析方式一般分为两种Dom和Sax 解析。
- Dom解析:把整个数据看做是一个Dom对象,将他们一次性读入内存,功耗大, 解析难度低
- Sax解析:Sax采用逐步解析的方式,占用内存小,特点是方便、灵活,解析相对 麻烦
- json:一种轻量级的数据交换格式,“{”表示一个字典的开始,“}”表示一个字典 的结束,“[”表示一个数组的开始,“]”表示一个数组的结束。
  
<h2 id="解析的开源框架"> 解析的开源框架 </h2>

- XML Dom解析,GDataXMLNode,XMLDictionary等
- XML Sax解析,NSXMLParser等
- JSON 解析,JSONKit,iOS5之后系统自带解析库等

XML 解析：

- GDataXMLNode

	- 需要导入的依赖库：libxml2.dylib
	- 修改工程配置target -> build setting -> header search path -> ${SDKROOT}/usr/include/libxml2

		`- (id)initWithXMLString:(NSString *)str options:(unsigned int)mask error:(NSError `**`)error;`
- 节点解析

		- (NSArray *)elementsForName:(NSString *)name;
		- (NSArray *)children;
- XPath解析

	`- (NSArray *)nodesForXPath:(NSString *)xPath error:(NSError `**`)error;`
	
***

<h1 id="ASIHTTPRequest"> ASIHTTPRequest </h1>

使用ASIHTTPRequest需要导入其依赖库：

- SystemConfiguration.framework
- MessageUI.framework
- MobileCoreServices.framework
- CFNetwork.framework
- libz.1.2.5.dylib

**TIPS**

- ASIHTTPRequest类用于实现HTTP GET请求，也是作为POST请求的父类
- ASIHTTPRequest继承于NSOperation，所以即可以直接被执行，也可以加入队列中由队列管理
- ASIFormDataRequest继承于ASIHTTPRequest，实现了HTTP POST请求，并拥有父类的全部特性
- ASINetworkQueue继承于NSOperationQueue，提供了网络请求队列功能，管理其内部的所有请求

***



