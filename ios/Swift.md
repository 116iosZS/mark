Swift Issues

***

[字符串是值类型](#字符串是值类型)
[结构体和枚举是值类型](#结构体和枚举是值类型)
[类和结构体的选择](#类和结构体的选择)
[集合类型(Collection)的赋值和拷贝行为](#集合类型的赋值和拷贝行为)

***
# 字符串是值类型

Swift的`String`类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数、方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 

> 注意：与 Cocoa 中的NSString不同，当您在 Cocoa 中创建了一个NSString实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该NSString实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。

# 结构体和枚举是值类型

`值类型被赋予给一个变量，常数或者本身被传递给一个函数的时候，实际上操作的是其的拷贝`

在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Booleans）、字符串（string)、数组（array）和字典（dictionaries），都是值类型，并且都是以结构体的形式在后台所实现

在 Swift 中，所有的结构体和枚举都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制

# 类和结构体的选择

当符合一条或多条以下条件时，请考虑构建结构体：

- 结构体的主要目的是用来封装少量相关简单数据值。
- 有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。
- 任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。
- 结构体不需要去继承另一个已存在类型的属性或者行为。

合适的结构体候选者包括：

- 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
- 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
- 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。

# 集合类型的赋值和拷贝行为

Swift中`数组（Array）`和字典`（Dictionary）`类型均以结构体的形式实现。

`NSArray`和`NSDictionary`实例总是以对已有实例引用,而不是拷贝的方式被赋值和传递

如果`字典`实例中所储存的键（keys）和/或值（values）是值类型（结构体或枚举），当赋值或调用发生时，它们都会被拷贝。相反，如果键（keys）和/或值（values）是引用类型，被拷贝的将会是引用，而不是被它们引用的类实例或函数。字典的键和值的拷贝行为与结构体所储存的属性的拷贝行为相同。

在Swift 中，数组`（Arrays）`类型的赋值和拷贝行为要比字典`（Dictionary）`类型的复杂的多。当操作数组内容时，数组（Array）能提供接近C语言的的性能，并且拷贝行为只有在必要时才会发生。

如果你将一个数组（Array）实例赋给一个变量或常量，或者将其作为参数传递给函数或方法调用，在事件发生时数组的内容不会被拷贝。相反，数组公用相同的元素序列。当你在一个数组内修改某一元素，修改结果也会在另一数组显示。

对数组来说，拷贝行为仅仅当操作有可能修改数组长度时才会发生。这种行为包括了附加（appending）,插入（inserting）,删除（removing）或者使用范围下标（ranged subscript）去替换这一范围内的元素。只有当数组拷贝确要发生时，数组内容的行为规则与字典中键值的相同

代码分析：

```swift
var dic = [0:0, 1:0, 2:0]  
var newDic = dic  
//Check dic and newDic
dic[0] = 1  
dic    //[0: 1, 1: 0, 2: 0]  
newDic //[0: 0, 1: 0, 2: 0]

var arr = [0,0,0]  
var newArr = arr  
arr[0] = 1  
//Check arr and newArr
arr    //[1, 0, 0]  
newArr //[1, 0, 0]  
```

```swift
var arr = [0,0,0]  
var copiedArr = arr.copy()

arr[0] = 1  
arr       //[1, 0, 0]  
copiedArr //[0, 0, 0]  
```

> oneV's Den: Array 在 copy 时执行的不是深拷贝，所以 Array 中的参照类型在拷贝之后仍然会是参照。Array 中嵌套 Array 的情况亦是如此：对一个 Array 进行的 copy 只会将被拷贝的 Array 指向新的地址，而保持其中所有其他 Array 的引用。

```swift
var arr = [0,0,0]  
var newArr = Array(arr)

arr[0] = 1  
arr       //[1, 0, 0]  
newArr    //[0, 0, 0]  
```

```swift
var arr = [0,0,0]  
var newArr = arr

// arr's address 0x10490000

arr.unshare()

// newArr's address 0x10490000
// arr's address 0x0f0c0000

arr[0] = 1  
arr       //[1, 0, 0]  
newArr    //[0, 0, 0]  
```

>  注意：如果你仅需要确保你对数组的引用是唯一引用，请调用unshare方法，而不是copy方法。unshare方法仅会在确有必要时才会创建数组拷贝。copy方法会在任何时候都创建一个新的拷贝，即使引用已经是唯一引用。

> oneV's Den: unshare() 的作用是如果对象数组不是唯一参照，则复制一份，并将作用的参照指向新的地址（这样它就变成唯一参照，不会意外改变原来的别的同样的参照了）；而如果这个参照已经是唯一参照了的话，就什么都不做

































































































