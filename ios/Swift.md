# Swift Issues

***

## 目录

- [字符串是值类型](#字符串是值类型)
- [结构体和枚举是值类型](#结构体和枚举是值类型)
- [类和结构体的选择](#类和结构体的选择)
- [集合类型(Collection)的赋值和拷贝行为](#集合类型的赋值和拷贝行为)
- [属性](#属性)
- [构造过程](#构造过程)

***

## 字符串是值类型

Swift的`String`类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作或在函数、方法中传递时，会进行值拷贝。 任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。 

> 注意：与 Cocoa 中的NSString不同，当您在 Cocoa 中创建了一个NSString实例，并将其传递给一个函数/方法，或者赋值给一个变量，您传递或赋值的是该NSString实例的一个引用，除非您特别要求进行值拷贝，否则字符串不会生成新的副本来进行赋值操作。

## 结构体和枚举是值类型

`值类型被赋予给一个变量，常数或者本身被传递给一个函数的时候，实际上操作的是其的拷贝`

在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Booleans）、字符串（string)、数组（array）和字典（dictionaries），都是值类型，并且都是以结构体的形式在后台所实现

在 Swift 中，所有的结构体和枚举都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制

## 类和结构体的选择

当符合一条或多条以下条件时，请考虑构建结构体：

- 结构体的主要目的是用来封装少量相关简单数据值。
- 有理由预计一个结构体实例在赋值或传递时，封装的数据将会被拷贝而不是被引用。
- 任何在结构体中储存的值类型属性，也将会被拷贝，而不是被引用。
- 结构体不需要去继承另一个已存在类型的属性或者行为。

合适的结构体候选者包括：

- 几何形状的大小，封装一个width属性和height属性，两者均为Double类型。
- 一定范围内的路径，封装一个start属性和length属性，两者均为Int类型。
- 三维坐标系内一点，封装x，y和z属性，三者均为Double类型。

## 集合类型的赋值和拷贝行为

Swift中`数组（Array）`和字典`（Dictionary）`类型均以结构体的形式实现。

`NSArray`和`NSDictionary`实例总是以对已有实例引用,而不是拷贝的方式被赋值和传递

如果`字典`实例中所储存的键（keys）和/或值（values）是值类型（结构体或枚举），当赋值或调用发生时，它们都会被拷贝。相反，如果键（keys）和/或值（values）是引用类型，被拷贝的将会是引用，而不是被它们引用的类实例或函数。字典的键和值的拷贝行为与结构体所储存的属性的拷贝行为相同。

在Swift 中，数组`（Arrays）`类型的赋值和拷贝行为要比字典`（Dictionary）`类型的复杂的多。当操作数组内容时，数组（Array）能提供接近C语言的的性能，并且拷贝行为只有在必要时才会发生。

如果你将一个数组（Array）实例赋给一个变量或常量，或者将其作为参数传递给函数或方法调用，在事件发生时数组的内容不会被拷贝。相反，数组公用相同的元素序列。当你在一个数组内修改某一元素，修改结果也会在另一数组显示。

对数组来说，拷贝行为仅仅当操作有可能修改数组长度时才会发生。这种行为包括了附加（appending）,插入（inserting）,删除（removing）或者使用范围下标（ranged subscript）去替换这一范围内的元素。只有当数组拷贝确要发生时，数组内容的行为规则与字典中键值的相同

代码分析：

```swift
var dic = [0:0, 1:0, 2:0]  
var newDic = dic  
//Check dic and newDic
dic[0] = 1  
dic    //[0: 1, 1: 0, 2: 0]  
newDic //[0: 0, 1: 0, 2: 0]

var arr = [0,0,0]  
var newArr = arr  
arr[0] = 1  
//Check arr and newArr
arr    //[1, 0, 0]  
newArr //[1, 0, 0]  
```

```swift
var arr = [0,0,0]  
var copiedArr = arr.copy()

arr[0] = 1  
arr       //[1, 0, 0]  
copiedArr //[0, 0, 0]  
```

> oneV's Den: Array 在 copy 时执行的不是深拷贝，所以 Array 中的参照类型在拷贝之后仍然会是参照。Array 中嵌套 Array 的情况亦是如此：对一个 Array 进行的 copy 只会将被拷贝的 Array 指向新的地址，而保持其中所有其他 Array 的引用。

```swift
var arr = [0,0,0]  
var newArr = Array(arr)

arr[0] = 1  
arr       //[1, 0, 0]  
newArr    //[0, 0, 0]  
```

```swift
var arr = [0,0,0]  
var newArr = arr

// arr's address 0x10490000

arr.unshare()

// newArr's address 0x10490000
// arr's address 0x0f0c0000

arr[0] = 1  
arr       //[1, 0, 0]  
newArr    //[0, 0, 0]  
```

>  注意：如果你仅需要确保你对数组的引用是唯一引用，请调用unshare方法，而不是copy方法。unshare方法仅会在确有必要时才会创建数组拷贝。copy方法会在任何时候都创建一个新的拷贝，即使引用已经是唯一引用。

> oneV's Den: unshare() 的作用是如果对象数组不是唯一参照，则复制一份，并将作用的参照指向新的地址（这样它就变成唯一参照，不会意外改变原来的别的同样的参照了）；而如果这个参照已经是唯一参照了的话，就什么都不做

***

## 属性

> 必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值

***

> 不需要为无法重载的计算属性添加属性监视器，因为可以通过setter直接监控和响应值的变化

***

> `willSet`和`didSet`监视器在属性初始化过程中不会被调用，它们只会当属性的值在初始化之外的地方被设置时被调用

***

> 全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记`@lazy`特性。局部范围的常量或变量不会延迟计算

可以将一个继承来的只读属性重写为一个读写属性，只需要你在重写版本的属性里提供getter和setter
即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性

> 如果你在重写属性中提供了setter，那么你也一定要提供getter。如果你不想在重写版本中的getter里修改继承来的属性值，你可以直接返回super.someProperty来返回继承来的值

***

> 不可以同时提供重写的setter和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的setter，那么你在setter中就可以观察到任何值变化了

***

## 构造过程

只要在构造过程结束前常量的值能确定，你可以在构造过程中的任意时间点修改常量属性的值。

> 对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改

构造器之间的代理调用规则:

- 指定构造器必须调用其直接父类的的指定构造器
- 便利构造器必须调用同一类中定义的其它构造器
- 便利构造器必须最终以调用一个指定构造器结束

## 通过闭包和函数来设置属性的默认值

```swift
class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
        }()
}
```
注意闭包结尾的大括号后面接了一对空的小括号。这是用来告诉 Swift
需要立刻执行此闭包。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。

> 如果你使用闭包来初始化属性的值，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能够在闭包里访问其它的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐式的self属性，或者调用其它的实例方法
