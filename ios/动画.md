# 动画

- [转场动画](#转场动画)
	- [iOS7之前的VC切换解决方案](#iOS7之前的VC切换解决方案)
	- [iOS7中的ViewController切换](#iOS7中的ViewController切换)
- [购物车曲线动画](#购物车曲线动画)
- [CABasicAnimation](#CABasicAnimation)


<h1 id="转场动画"> 转场动画 </h1>

<h2 id="iOS7之前的VC切换解决方案"> iOS7之前的VC切换解决方案 </h2>

[Source](http://www.cnblogs.com/EnamelPot/p/3465561.html "Permalink to UIViewController切换（ios5：transitionFromViewController） - EnamelPot - 博客园")

    @property(nonatomic,readonly) NSArray *childViewControllers

    - (void)addChildViewController:(UIViewController *)childController
    - (void) removeFromParentViewController
    - (void)transitionFromViewController：：：：：：
    - (void)willMoveToParentViewController:(UIViewController *)parent
    - (void)didMoveToParentViewController:(UIViewController *)parent

childViewControllers：一个数组，里面是子vc。&nbsp;

addChildViewController:向视图控制器容器中添加子视图控制器

removeFromParentViewController：从父视图控制器中删除

transitionFromViewController：交换两个子视图控制器的位置（由于添加的顺序不同，所以子试图控制器在父视图控制器中存在层次关系）

  * fromViewController：当前显示的子试图控制器，将被替换为非显示状态
  * toViewController：将要显示的子视图控制器
  * duration：交换动画持续的时间，单位秒
  * options：动画的方式
  * animations：动画Block
  * completion：完成后执行的Block

willMoveToParentViewController:当一个视图控制器从视图控制器容器中被添加或者被删除之前，该方法被调用

  * parent：父视图控制器，如果没有父视图控制器，将为nil
  * 当我们向我们的视图控制器容器中调用removeFromParentViewController方法时，必须要先调用该方法，且parent参数为nil：
  * 当我们调用addChildViewController方法时，在添加子视图控制器之前将自动调用该方法。所以，就不需要我们显示调用了。

didMoveToParentViewController:当从一个视图控制容器中添加或者移除viewController后，该方法被调用。

  * parent：父视图控制器，如果没有父视图控制器，将为nil
  * 在调用addChildViewController方法加入子视图控制器后，必须调用该方法，告诉iOS，已经完成添加（或删除）子控制器的操作。
  * removeFromParentViewController 方法会自动调用了该方法，所以，删除子控制器后，不需要在显示的调用该方法了。

小结一下：

*（add + did）\[被加入的子视图控制器 didMoveToParentViewController:父视图控制器\];
*（will+transition+did）\[子视图控制器 willMoveToParentViewController:nil\] transition \[子视图控制器 didMoveToParentViewController:父视图控制器\]；
*（will+remove）\[被删除的子试图控制器 willMoveToParentViewController:nil\];

1. 在appDelegate中设置rootviewcontroller为mainVC

	`self.window.rootViewController = [[mainViewController alloc]initWithNibName:nil bundle:nil];`

2. 在mainVC中设置2个按钮

	    UIButton *fristButton = [[UIButton alloc]initWithFrame:CGRectMake(0, 20, 160, 40)];
	    fristButton.backgroundColor = [UIColor yellowColor];
	    [fristButton addTarget:self action:@selector(toShowTheFristViewController) forControlEvents:UIControlEventTouchUpInside];
	    [self.view addSubview:fristButton];
	
	    UIButton *secondButton = [[UIButton alloc]initWithFrame:CGRectMake(160, 20, 160, 40)];
	    secondButton.backgroundColor = [UIColor blueColor];
	    [secondButton addTarget:self action:@selector(toShowTheSecondViewController) forControlEvents:UIControlEventTouchUpInside];
	    [self.view addSubview:secondButton];

3. 新建所有的子vc，addChildViewController进mainVC，new一个UIView，在其中addSubview想要展示的第一个vc的view

	    FristViewController *fVC=[[FristViewController alloc]initWithNibName:nil bundle:nil];
	    [self addChildViewController:fVC];
	    SecondViewController *sVC=[[SecondViewController alloc]initWithNibName:nil bundle:nil];
	    [self addChildViewController:sVC];
	
	    [mainView addSubview:fVC.view];

4. 添加2个按钮方法

		- (void)toShowTheFristViewController {
    	NSLog(@"显示第一个vc");
    	[[self.childViewControllers objectAtIndex:1] willMoveToParentViewController:nil];
    	[self transitionFromViewController:[self.childViewControllers objectAtIndex:0]
                      toViewController:[self.childViewControllers objectAtIndex:1]
                              duration:0.3
                              options:UIViewAnimationOptionTransitionFlipFromLeft
                               animations:^{}
                            completion:^(BOOL finished) {
	                            }];
	                            [[self.childViewControllers objectAtIndex:0] didMoveToParentViewController:self];
		}
	
		- (void)toShowTheSecondViewController {
		    NSLog(@"显示第二个vc");
		    [[self.childViewControllers objectAtIndex:0] willMoveToParentViewController:nil];
		    [self transitionFromViewController:[self.childViewControllers objectAtIndex:1]
		                      toViewController:[self.childViewControllers objectAtIndex:0]
		                              duration:0.3
		                               options:UIViewAnimationOptionTransitionFlipFromLeft
		                            animations:^{}
		                            completion:^(BOOL finished) {
		                            }];
		    [[self.childViewControllers objectAtIndex:1]didMoveToParentViewController:self];
		}
 
oneV's Den demo:

	 // ContainerVC.m
	 [self addChildViewController:toVC];
	 [fromVC willMoveToParentViewController:nil];
	 [self.view addSubview:toVC.view];

	 __weak id weakSelf = self;
	 [self transitionFromViewController:fromVC
	                   toViewController:toVC duration:0.3
	                            options:UIViewAnimationOptionTransitionCrossDissolve
	                         animations:^{}
	                         completion:^(BOOL finished) {
	     [fromVC.view removeFromSuperView];
	     [fromVC removeFromParentViewController];
	     [toVC didMoveToParentViewController:weakSelf];
	 }];

**animation中可以添加动画**
 
	CATransition *animation = [CATransition animation];
	animation.duration = 0.5;
	animation.type = kCATransitionReveal;
	animation.subtype =kCATransitionFromLeft;
	[rootVC.view.layer addAnimation:animation forKey:@"animate"];

<h2 id="iOS7中的ViewController切换"> iOS7中的ViewController切换 </h2>

source:[OneV'S Den](#http://onevcat.com/2013/10/vc-transition-in-ios7/)

自定义动画切换的相关的主要API:

**@protocol UIViewControllerContextTransitioning**

这个接口用来提供切换上下文给开发者使用，包含了从哪个VC到哪个VC等各类信息,这个接口中最重要的方法有：

* \- (UIView *)containerView; VC切换所发生的view容器，开发者应该将切出的view移除，将切入的view加入到该view容器中。
* \- (UIViewController )viewControllerForKey:(NSString )key; 提供一个key，返回对应的VC。现在的SDK中key的选择只有UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别表示将要切出和切入的VC。
* \- (CGRect)initialFrameForViewController:(UIViewController *)vc; 某个VC的初始位置，可以用来做动画的计算。
* \- (CGRect)finalFrameForViewController:(UIViewController *)vc; 与上面的方法对应，得到切换结束时某个VC应在的frame。
* \- (void)completeTransition:(BOOL)didComplete; 向这个context报告切换已经完成。

**@protocol UIViewControllerAnimatedTransitioning**

这个接口负责切换的具体内容，也即“切换中应该发生什么”。开发者在做自定义切换效果时大部分代码会是用来实现这个接口。它只有两个方法需要我们实现：

	// 系统给出一个切换上下文，我们根据上下文环境返回这个切换所需要的花费时间
	-(NSTimeInterval)transitionDuration:(id < UIViewControllerContextTransitioning >)transitionContext;
	//在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。
	-(void)animateTransition:(id < UIViewControllerContextTransitioning >)transitionContext; 

**@protocol UIViewControllerTransitioningDelegate**

在需要VC切换的时候系统会像实现了这个接口的对象询问是否需要使用自定义的切换效果。这个接口共有四个类似的方法：

	- (id< UIViewControllerAnimatedTransitioning >)animationControllerForPresentedController:(UIViewController )presented presentingController:(UIViewController )presenting sourceController:(UIViewController *)source;
	- (id< UIViewControllerAnimatedTransitioning >)animationControllerForDismissedController:(UIViewController *)dismissed;
	- (id< UIViewControllerInteractiveTransitioning >)interactionControllerForPresentation:(id < UIViewControllerAnimatedTransitioning >)animator;
	- (id< UIViewControllerInteractiveTransitioning >)interactionControllerForDismissal:(id < UIViewControllerAnimatedTransitioning >)animator;

前两个方法是针对动画切换的，我们需要分别在呈现VC和解散VC时，给出一个实现了UIViewControllerAnimatedTransitioning接口的对象（其中包含切换时长和如何这个接口用来提供切换上下文给开发者使用切换）

Demo:

1. 先定义一个ModalVC，以及相应的protocal和delegate方法：

		// ModalViewController.h
		
		@class ModalViewController;
		@protocol ModalViewControllerDelegate <NSObject>
		
		-(void) modalViewControllerDidClickedDismissButton:(ModalViewController *)viewController;
		
		@end
		
		@interface ModalViewController : UIViewController
		@property (nonatomic, weak) id<ModalViewControllerDelegate> delegate;
		@end

		//ModalViewController.m
		- (void)viewDidLoad
		{
		    [super viewDidLoad];
		  // Do any additional setup after loading the view.
		    self.view.backgroundColor = [UIColor lightGrayColor];
		
		    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
		    button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0);
		    [button setTitle:@"Dismiss me" forState:UIControlStateNormal];
		    [button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];
		    [self.view addSubview:button];
		}
		
		-(void) buttonClicked:(id)sender
		{
		    if (self.delegate && [self.delegate respondsToSelector:@selector(modalViewControllerDidClickedDismissButton:)]) {
		        [self.delegate modalViewControllerDidClickedDismissButton:self];
		    }
		}

		// MainViewController.m
		
		- (void)viewDidLoad
		{
		    [super viewDidLoad];
		
		    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];
		    button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0);
		    [button setTitle:@"Click me" forState:UIControlStateNormal];
		    [button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];
		    [self.view addSubview:button];
		}
		
		-(void) buttonClicked:(id)sender
		{
		    ModalViewController *mvc =  [[ModalViewController alloc] init];
		    mvc.delegate = self;
		    [self presentViewController:mvc animated:YES completion:nil];
		}
		
		-(void)modalViewControllerDidClickedDismissButton:(ModalViewController *)viewController
		{
		    [self dismissViewControllerAnimated:YES completion:nil];
		}

首先我们需要一个实现了UIViewControllerAnimatedTransitioning的对象.比如BouncePresentAnimation：

	// BouncePresentAnimation.h
	@interface BouncePresentAnimation : NSObject<UIViewControllerAnimatedTransitioning>
	
	@end
	
	// BouncePresentAnimation.m
	- (NSTimeInterval)transitionDuration:(id <UIViewControllerContextTransitioning>)transitionContext
	{
	    return 0.8f;
	}

	- (void)animateTransition:(id <UIViewControllerContextTransitioning>)transitionContext
	{
	    // 1. Get controllers from transition context
	    UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];
	
	    // 2. Set init frame for toVC
	    CGRect screenBounds = [[UIScreen mainScreen] bounds];
	    CGRect finalFrame = [transitionContext finalFrameForViewController:toVC];
	    toVC.view.frame = CGRectOffset(finalFrame, 0, screenBounds.size.height);
	
	    // 3. Add toVC's view to containerView
	    UIView *containerView = [transitionContext containerView];
	    [containerView addSubview:toVC.view];
	
	    // 4. Do animate now
	    NSTimeInterval duration = [self transitionDuration:transitionContext];
	    [UIView animateWithDuration:duration
	                          delay:0.0
	         usingSpringWithDamping:0.6
	          initialSpringVelocity:0.0
	                        options:UIViewAnimationOptionCurveLinear
	                     animations:^{
	                         toVC.view.frame = finalFrame;
	                     } completion:^(BOOL finished) {
	                         // 5. Tell context that we completed.
	                         [transitionContext completeTransition:YES];
	                     }];
	}

解释：

1. 我们首先需要得到参与切换的两个ViewController的信息，使用context的方法拿到它们的参照；
2. 对于要呈现的VC，我们希望它从屏幕下方出现，因此将初始位置设置到屏幕下边缘；
3. 将view添加到containerView中；
4. 开始动画。这里的动画时间长度和切换时间长度一致，都为0.8s。usingSpringWithDamping的UIView动画API是iOS7新加入的，描述了一个模拟弹簧动作的动画曲线，我们在这里只做使用，更多信息可以参看相关文档；（顺便多说一句，iOS7中对UIView动画添加了一个很方便的Category，UIViewKeyframeAnimations。使用其中方法可以为UIView动画添加关键帧动画）
5. 在动画结束后我们必须向context报告VC切换完成，是否成功（在这里的动画切换中，没有失败的可能性，因此直接pass一个YES过去）。系统在接收到这个消息后，将对VC状态进行维护。
6. 接下来我们实现一个UIViewControllerTransitioningDelegate，应该就能让它工作了。简单来说，一个比较好的地方是直接在MainViewController中实现这个接口。在MainVC中声明实现这个接口，然后加入或变更为如下代码：
	
		@interface MainViewController ()<ModalViewControllerDelegate, UIViewControllerTransitioningDelegate>
		@property (nonatomic, strong) BouncePresentAnimation *presentAnimation;
		@end
		
		@implementation MainViewController
		
		- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
		{
		    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
		    if (self) {
		        // Custom initialization
		        _presentAnimation = [BouncePresentAnimation new];
		    }
		    return self;
		}
		
		-(void) buttonClicked:(id)sender
		{
		    //...
		    mvc.transitioningDelegate = self;
		    //...
		}
		
		- (id <UIViewControllerAnimatedTransitioning>)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source
		{
		    return self.presentAnimation;
		}
		
***

<h2 id="购物车曲线动画"> 购物车曲线动画 </h2>

	CAKeyframeAnimation *animation=[CAKeyframeAnimation animationWithKeyPath:@"position"];
	animation.duration = 1.0f;
	animation.timingFunction = [CAMediaTimingFunction functionWithName:@"easeInEaseOut"];
	animation.fillMode = kCAFillModeForwards;
	animation.calculationMode = kCAAnimationCubicPaced;
	animation.removedOnCompletion = YES;
	animation.delegate = self;
	CGMutablePathRef curvedPath = CGPathCreateMutable();
	CGPathMoveToPoint(curvedPath, NULL, CGRectGetMidX(self.bounds),
	                  CGRectGetMidY(self.bounds) + 100);
	CGPathAddQuadCurveToPoint(curvedPath, NULL, 30, 100, 40, 700);
	animation.path = curvedPath;
	[_imageView.layer addAnimation:animation forKey:nil];
	CGPathRelease(curvedPath);

***

<h1 id="CABasicAnimation"> CABasicAnimation </h1>

平移动画

    CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @"position.x";  
    animation.fromValue = @77;
    animation.toValue = @455;
    animation.duration = 1;
    [rocket.layer addAnimation:animation forKey:@"basic"];

支持的键路径的完整列表

    rotation.x
    Set to an NSNumber object whose value is the rotation, in radians, in the x axis.
    rotation.y
    Set to an NSNumber object whose value is the rotation, in radians, in the y axis.
    rotation.z
    Set to an NSNumber object whose value is the rotation, in radians, in the z axis.
    rotation
    Set to an NSNumber object whose value is the rotation, in radians, in the z axis. This field is identical to setting the rotation.z field.
    scale.x
    Set to an NSNumber object whose value is the scale factor for the x axis.
    scale.y
    Set to an NSNumber object whose value is the scale factor for the y axis.
    scale.z
    Set to an NSNumber object whose value is the scale factor for the z axis.
    scale
    Set to an NSNumber object whose value is the average of all three scale factors.
    translation.x
    Set to an NSNumber object whose value is the translation factor along the x axis.
    translation.y
    Set to an NSNumber object whose value is the translation factor along the y axis.
    translation.z
    Set to an NSNumber object whose value is the translation factor along the z axis.
    translation
    Set to an NSValue object containing an NSSize or CGSize data type. That data type indicates the amount to translate in the x and y axis.

***